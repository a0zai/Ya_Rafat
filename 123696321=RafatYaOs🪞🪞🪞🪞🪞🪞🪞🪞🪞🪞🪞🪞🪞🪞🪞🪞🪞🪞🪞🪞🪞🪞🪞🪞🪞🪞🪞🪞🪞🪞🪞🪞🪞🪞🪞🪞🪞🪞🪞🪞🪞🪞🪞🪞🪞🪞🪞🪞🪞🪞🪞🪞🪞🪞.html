<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>A∞Z | Mirror Interface</title>
<style>
  body {
    background: url('IMG_9055.jpeg') no-repeat center center fixed;
    background-size: cover;
    color: #00ffcc;
    font-family: "Courier New", Courier, monospace;
    padding: 2em;
    overflow: hidden;
    backdrop-filter: brightness(0.7);
  }
  /* إخفاء النصوص */
  #output {
    display: none;
  }
</style>
</head>
<body>
  <div id="output"></div>
  <button id="startBtn" style="padding:10px 20px; font-size:16px;">Start</button>

<script>
let shouldSpeak = true;
const startBtn = document.getElementById('startBtn');
const output = document.getElementById('output');

function loadVoices() {
  return new Promise(resolve => {
    let voices = speechSynthesis.getVoices();
    if (voices.length) {
      resolve(voices);
    } else {
      speechSynthesis.onvoiceschanged = () => {
        voices = speechSynthesis.getVoices();
        resolve(voices);
      };
    }
  });
}

function speakLine(text) {
  if (!shouldSpeak || !text) return;

  speechSynthesis.cancel();

  const utterance = new SpeechSynthesisUtterance(text);
  utterance.lang = 'en-US';
  utterance.rate = 0.7;
  utterance.pitch = 0.3;
  speechSynthesis.speak(utterance);
}

async function typeLine(container, obj, charDelay = 40) {
  // لا نضيف أي نص للعناصر لأنه مخفي، لكن دالة typeLine يجب تبقى لانتظار الوقت
  await new Promise(resolve => setTimeout(resolve, obj.text.length * charDelay + 50));
  speakLine(obj.speak);
}

async function delayPrint(lines, lineDelay = 600, charDelay = 40) {
  for (let obj of lines) {
    await typeLine(output, obj, charDelay);
    await new Promise(resolve => setTimeout(resolve, lineDelay));
  }
}

async function getIPData() {
  try {
    const response = await fetch("https://ipapi.co/json/");
    if (!response.ok) throw new Error("IP API Error");
    return await response.json();
  } catch {
    return null;
  }
}

async function getGeolocation() {
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) {
      reject("Geolocation not supported.");
    } else {
      navigator.geolocation.getCurrentPosition(
        position => resolve(position.coords),
        error => reject(error.message)
      );
    }
  });
}

async function main() {
  startBtn.disabled = true;

  await loadVoices();

  let ipInfo = await getIPData();
  let gpsCoords = null;

  try {
    gpsCoords = await getGeolocation();
  } catch (e) {
    // خطأ أو رفض الإذن
  }

  const now = new Date();
  const timeString = now.toLocaleString();

  const ua = navigator.userAgent;
  const width = window.screen.width;
  const height = window.screen.height;
  const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;

  let ip = ipInfo?.ip || "Unavailable";
  let city = ipInfo?.city || "Unavailable";
  let region = ipInfo?.region || "Unavailable";
  let country = ipInfo?.country_name || "Unavailable";

  const sessionId = btoa(ip + ua).slice(0, 16);

  const lines = [
    { text: "[ A∞Z | Mirror Interface ]", speak: "Welcome to A infinity Z mirror interface" },
    { text: "", speak: "" },
    { text: "Session: " + sessionId, speak: "Session ID is " + sessionId },
    { text: "Time: " + timeString, speak: "The current time is " + timeString },
    { text: "IP Address: " + ip, speak: "The IP address is " + ip },
    { text: "City: " + city, speak: "The user lives in " + city },
    { text: "Region: " + region, speak: "The region is " + region },
    { text: "Country: " + country, speak: "The country is " + country },
    { text: "Device: " + ua, speak: "The user is using device " + ua },
    { text: "Screen: " + width + "x" + height, speak: "Screen resolution is " + width + " by " + height },
    { text: "Timezone: " + timezone, speak: "The timezone is " + timezone },
    { text: gpsCoords ? "Latitude: " + gpsCoords.latitude.toFixed(6) : "Latitude: Unavailable",
      speak: gpsCoords ? "Latitude is " + gpsCoords.latitude.toFixed(6) : "Latitude is unavailable" },
    { text: gpsCoords ? "Longitude: " + gpsCoords.longitude.toFixed(6) : "Longitude: Unavailable",
      speak: gpsCoords ? "Longitude is " + gpsCoords.longitude.toFixed(6) : "Longitude is unavailable" }
  ];

  await delayPrint(lines, 800, 50);
}

startBtn.addEventListener('click', () => {
  startBtn.style.display = 'none';
  main();
});
</script>
</body>
</html>